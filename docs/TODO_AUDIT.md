# Lumen Codebase Audit: TODOs, Stubs, and Incomplete Implementations

**Date**: 2026-02-14
**Scope**: All `.rs` files under `/home/Allie/develop/lumen/rust/`
**Focus**: Compiler pipeline (parser, resolver, typechecker, lower, VM), CLI, runtime, providers

---

## Summary

| Category | Count | Critical | Important | Minor |
|----------|-------|----------|-----------|-------|
| `todo!()` | 0 | 0 | 0 | 0 |
| `unimplemented!()` | 0 | 0 | 0 | 0 |
| `// TODO` | 3 | 0 | 1 | 2 |
| `// FIXME` | 0 | 0 | 0 | 0 |
| `// HACK` | 0 | 0 | 0 | 0 |
| `unreachable!()` (prod) | 4 | 0 | 0 | 4 |
| `panic!()` (prod) | 2 | 0 | 1 | 1 |
| `.unwrap()` (prod) | 14 | 0 | 3 | 11 |
| Silent `_ => {}` (prod) | ~18 | 1 | 4 | 13 |
| Missing lowering arm | 1 | 1 | 0 | 0 |

**Overall assessment**: The codebase is clean. There are zero `todo!()` or `unimplemented!()` macros. The few issues found are localized and low-severity, with one exception: `Stmt::Defer` is parsed but not lowered (active WIP from round 18).

---

## CRITICAL

### 1. `Stmt::Defer` parsed but not lowered (compile-breaking)

- **File**: `rust/lumen-compiler/src/compiler/lower.rs` (function `lower_stmt`, line ~801)
- **Context**: The `DeferStmt` variant was added to the AST in `ast.rs:340` and the parser generates it (`parser.rs:1956`), but the `lower_stmt` match does not handle `Stmt::Defer`. The compiler currently fails to compile with:
  ```
  error[E0004]: non-exhaustive patterns: `&ast::Stmt::Defer(_)` not covered
  ```
- **Severity**: CRITICAL -- the compiler crate itself does not build
- **Status**: Active work-in-progress (Task #2: "Wire lowering for destructuring let, defer blocks, and property shorthand")
- **Suggested fix**: Add `Stmt::Defer` arm to `lower_stmt` that collects deferred statements and emits them before `Return`/`Halt` or at function epilogue

---

## IMPORTANT

### 2. Missing output schema validation in runtime dispatch

- **File**: `rust/lumen-runtime/src/tools.rs:319` and `:342`
- **Context**:
  ```rust
  // TODO: Validate output against schema (output_schema)
  // For now, we skip validation to maintain backward compatibility
  ```
  Both `dispatch()` and `dispatch_async()` skip output validation. The `ToolError::OutputValidationFailed` variant exists but is never constructed.
- **Severity**: IMPORTANT -- tool outputs are not validated against declared schemas, which means type safety is not enforced at the tool boundary
- **Suggested fix**: After getting the tool response, validate `output` against `output_schema` if present. Emit `ToolError::OutputValidationFailed` on mismatch.

### 3. VM `SetIndex` silently ignores unsupported value types

- **File**: `rust/lumen-vm/src/vm.rs:1303`
- **Context**:
  ```rust
  OpCode::SetIndex => {
      match &mut self.registers[base + a] {
          Value::List(l) => { ... }
          Value::Map(m) => { m.insert(key.as_string(), val); }
          Value::Record(r) => { r.fields.insert(key.as_string(), val); }
          _ => {}  // silently ignored
      }
  }
  ```
  If `SetIndex` is executed on a `Value::Null`, `Value::Int`, `Value::String`, or any other non-container type, the operation is silently dropped. This could mask bugs in generated bytecode.
- **Severity**: IMPORTANT -- silent data loss on invalid operations
- **Suggested fix**: Return a `VmError::Runtime` for SetIndex on non-indexable types, or at minimum emit a debug trace event.

### 4. `panic!()` in `emit_json` / `emit_canonical_json`

- **File**: `rust/lumen-compiler/src/compiler/emit.rs:9` and `:16`
- **Context**:
  ```rust
  pub fn emit_json(module: &LirModule) -> String {
      serde_json::to_string_pretty(module).unwrap_or_else(|e| {
          panic!("Failed to serialize LIR module: {}", e);
      })
  }
  ```
  If serialization fails (unlikely but possible with custom Serialize impls), this panics instead of returning a Result.
- **Severity**: IMPORTANT -- these are public API functions used by `lumen emit`
- **Suggested fix**: Change return type to `Result<String, String>` and propagate the error.

### 5. Lowering: `CallArg::Role` silently dropped for intrinsics

- **File**: `rust/lumen-compiler/src/compiler/lower.rs:2009`
- **Context**:
  ```rust
  for arg in args {
      match arg {
          CallArg::Positional(e) | CallArg::Named(_, e, _) => {
              arg_regs.push(self.lower_expr(e, ra, consts, instrs));
          }
          _ => {} // Role not supported in intrinsics yet?
      }
  }
  ```
  The comment suggests this is intentionally deferred. If a `CallArg::Role` or any new variant is added, the intrinsic call will silently drop it.
- **Severity**: IMPORTANT -- could lead to wrong argument counts for intrinsic calls
- **Suggested fix**: Either handle `CallArg::Role` or emit a compile error when a role arg is passed to an intrinsic.

---

## MINOR

### 6. Missing Retry-After header extraction for Gemini rate limits

- **File**: `rust/lumen-provider-gemini/src/lib.rs:138`
- **Context**:
  ```rust
  429 => ToolError::RateLimit {
      retry_after_ms: None, // TODO: Extract from Retry-After header
      message,
  },
  ```
- **Severity**: MINOR -- rate limit errors are handled, just missing the retry delay hint
- **Suggested fix**: Parse the `Retry-After` header from the HTTP response and convert to milliseconds.

### 7. `unwrap()` in `lumen-provider-env` production code

- **File**: `rust/lumen-provider-env/src/lib.rs:266` and `:306`
- **Context**:
  ```rust
  EnvTool::List => {
      let vars: HashMap<String, String> = env::vars().collect();
      Ok(serde_json::to_value(vars).unwrap())
  }
  EnvTool::Args => {
      let args: Vec<String> = env::args().collect();
      Ok(serde_json::to_value(args).unwrap())
  }
  ```
  `serde_json::to_value` on `HashMap<String,String>` and `Vec<String>` should never fail in practice, but the unwrap is technically a crash point.
- **Severity**: MINOR -- practically impossible to trigger
- **Suggested fix**: Use `map_err` to convert to `ToolError::ExecutionFailed`.

### 8. LSP `unwrap()` calls on serde serialization

- **File**: `rust/lumen-lsp/src/main.rs` lines 84, 85, 96, 105, 659, 691, 707, 715, 723, 731
- **Context**: Multiple `unwrap()` calls in the LSP server main loop:
  ```rust
  let caps_json = serde_json::to_value(capabilities).unwrap();
  let _init_params = connection.initialize(caps_json).unwrap();
  // ...
  result: Some(serde_json::to_value(result).unwrap()),
  ```
  Most of these are on `serde_json::to_value` for well-typed structs which should never fail. The `connection.initialize().unwrap()` and `handle_shutdown().unwrap()` are protocol-level errors where crashing is arguably correct.
- **Severity**: MINOR -- standard for LSP servers; a crash restarts the server
- **Suggested fix**: No change needed. LSP servers are expected to crash-restart on protocol errors.

### 9. `unreachable!()` in VM for Call/TailCall/Intrinsic

- **File**: `rust/lumen-vm/src/vm.rs:1640`, `:1773`
- **Context**:
  ```rust
  OpCode::Call | OpCode::TailCall => {
      unreachable!()
  }
  OpCode::Intrinsic => {
      unreachable!()
  }
  ```
  These are in the main opcode dispatch, but Call/TailCall/Intrinsic are handled in a pre-match block above (lines 1114-1146) and `continue` before reaching here. The `unreachable!()` is correct.
- **Severity**: MINOR -- correctly placed; would only fire on a logic error in the pre-match
- **Suggested fix**: No change needed. These serve as safety nets.

### 10. `unreachable!()` in parser compound assign

- **File**: `rust/lumen-compiler/src/compiler/parser.rs:2068`
- **Context**: Catch-all in compound assignment operator parsing. Only reachable if `is_compound_assign_op()` returns true for a token that isn't handled. Correctly placed.
- **Severity**: MINOR -- would only fire on internal logic error
- **Suggested fix**: No change needed.

### 11. `unreachable!()` in lower for `BinOp::PipeForward`

- **File**: `rust/lumen-compiler/src/compiler/lower.rs:1714`
- **Context**: `BinOp::PipeForward => unreachable!()` -- pipe forward is desugared before reaching this point.
- **Severity**: MINOR -- correctly placed
- **Suggested fix**: No change needed.

### 12. `unreachable!()` in formatter match arm

- **File**: `rust/lumen-cli/src/fmt.rs:718`
- **Context**: In single-line match arm formatting, assumes the body is either `Return` or `Expr`.
- **Severity**: MINOR -- only fires if a match arm body contains an unexpected statement type
- **Suggested fix**: Consider adding a fallback that formats the arm in block style instead of crashing.

### 13. Lint `_ => {}` for unhandled Stmt/Expr/Item variants

- **File**: `rust/lumen-cli/src/lint.rs` lines 159, 272, 338, 391, 462, 593, 616
- **Context**: The linter has several `_ => {}` catch-alls when walking AST nodes. As new AST variants are added (e.g., `Stmt::Defer`, `Expr::PropertyShorthand`), the linter silently skips them.
- **Severity**: MINOR -- lint misses are low-impact compared to compiler correctness
- **Suggested fix**: Enumerate all variants explicitly in lint walks, or add a `#[deny(non_exhaustive_omitted_patterns)]` attribute.

### 14. Doc generator `_ => {}` for unhandled Item variants

- **File**: `rust/lumen-cli/src/doc.rs:168`
- **Context**: The doc generator only handles Cell, Record, Enum, TypeAlias, and Process items. Other items (Agent, Handler, Trait, Impl, Effect, Grant, etc.) are silently skipped.
- **Severity**: MINOR -- documentation generator is supplementary
- **Suggested fix**: Add documentation extraction for Trait, Impl, Effect, and Handler items.

### 15. Resolver `_ => {}` at end of type-checking pass

- **File**: `rust/lumen-compiler/src/compiler/resolve.rs:1078`
- **Context**: After handling all known items in the second resolver pass, the remaining items (Import, MacroDecl, EffectBind, UseTool, ConstDecl, Handler, etc.) fall through to `_ => {}`. This is correct because those items are handled in earlier passes.
- **Severity**: MINOR -- correct behavior, but loses exhaustiveness checking
- **Suggested fix**: Enumerate the remaining variants explicitly with `=> {}` for each.

### 16. Lowering `_ => {}` in `collect_free_idents_expr` and `collect_free_idents_stmt`

- **File**: `rust/lumen-compiler/src/compiler/lower.rs:2970` and `:3022`
- **Context**: Free identifier collection for closure capture analysis. Non-identifier expressions (literals, etc.) and unhandled statement types are skipped. Missing new AST variants would cause under-capture.
- **Severity**: MINOR -- could cause closures to miss captures for new expression types
- **Suggested fix**: Add explicit handling for all Expr/Stmt variants.

### 17. Lowering `_ => {}` for record construction with unknown CallArg

- **File**: `rust/lumen-compiler/src/compiler/lower.rs:1869`
- **Context**: During record construction lowering, unknown `CallArg` variants (beyond `Named` and `Positional`) are silently dropped.
- **Severity**: MINOR -- only `CallArg::Role` exists as an alternative
- **Suggested fix**: Emit a diagnostic or handle `CallArg::Role` for records.

### 18. Lowering `_ => {}` for unknown process kinds

- **File**: `rust/lumen-compiler/src/compiler/lower.rs:587`
- **Context**: When computing default methods for process kinds, unknown kinds are silently skipped. Only "memory", "machine", "pipeline", "orchestration" are recognized.
- **Severity**: MINOR -- new process kinds would need explicit support anyway
- **Suggested fix**: No change needed unless new process kinds are added.

### 19. `loop_stack.pop().unwrap()` in lowering

- **File**: `rust/lumen-compiler/src/compiler/lower.rs:945`, `:1034`, `:1054`
- **Context**: Popping loop context at the end of loop/while/for lowering. The push happens at the start of the same function, so this should always succeed unless there's a bug.
- **Severity**: MINOR -- would only panic on an internal logic error
- **Suggested fix**: Use `expect("loop stack underflow")` for a clearer error message.

### 20. Lexer `indent_stack.last().unwrap()`

- **File**: `rust/lumen-compiler/src/compiler/lexer.rs:133`, `:148`
- **Context**: The indent stack is initialized with `[0]` and only popped when there are multiple entries, so `last()` should never be None.
- **Severity**: MINOR -- invariant maintained by construction
- **Suggested fix**: No change needed.

### 21. Lexer `self.current().unwrap()` for scientific notation

- **File**: `rust/lumen-compiler/src/compiler/lexer.rs:676`
- **Context**: Inside a `matches!(self.current(), Some('+') | Some('-'))` guard, so the unwrap is safe.
- **Severity**: MINOR -- provably safe
- **Suggested fix**: No change needed.

### 22. Typecheck `non_null.into_iter().next().unwrap()`

- **File**: `rust/lumen-compiler/src/compiler/typecheck.rs:1423`, `:1476`
- **Context**: Inside a `if non_null.len() == 1` guard, so the unwrap is safe.
- **Severity**: MINOR -- provably safe
- **Suggested fix**: No change needed.

### 23. Typecheck single-char uppercase check

- **File**: `rust/lumen-compiler/src/compiler/typecheck.rs:311`
- **Context**: `name.chars().next().unwrap()` -- inside a `name.len() == 1` guard, so the unwrap is safe.
- **Severity**: MINOR -- provably safe
- **Suggested fix**: No change needed.

---

## Patterns NOT Found (Clean)

- **`todo!()`**: 0 occurrences -- all previously known TODOs have been resolved
- **`unimplemented!()`**: 0 occurrences -- no unimplemented markers remain
- **`// FIXME`**: 0 occurrences
- **`// HACK`**: 0 occurrences
- **`panic!()` in compiler pipeline production code**: 0 (only in tests and emit.rs)
- **`.unwrap()` in VM production code**: 0 (all unwraps are in test code)
- **`.unwrap()` in compiler production code (parser/resolve/typecheck/lower)**: 5, all provably safe

---

## Recommendations (Priority Order)

1. **Complete `Stmt::Defer` lowering** (CRITICAL, blocks compilation) -- Task #2 in progress
2. **Add output schema validation** in `ToolDispatcher::dispatch()` -- validates tool boundary types
3. **Return `VmError` for SetIndex on non-container types** -- prevents silent data loss
4. **Change `emit_json`/`emit_canonical_json` to return `Result`** -- removes panic from public API
5. **Handle `CallArg::Role` in intrinsic lowering** -- future-proofs against silent arg drops
6. **Improve lint/doc exhaustiveness** -- catch new AST variants automatically
