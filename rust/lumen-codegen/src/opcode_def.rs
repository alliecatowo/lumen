//! Unified opcode definition system
//!
//! Define an opcode ONCE, generate both interpreter dispatch and JIT code.
//!
//! # Design Goals
//!
//! 1. **Single Source of Truth**: One definition per opcode
//! 2. **Type Safety**: Statically enforce register types
//! 3. **Zero Overhead**: No runtime cost over hand-written code
//! 4. **Maintainability**: Changes automatically propagate to both backends
//!
//! # Architecture
//!
//! ```text
//! opcode_def.rs (this file)
//!     ↓
//! #[opcode] macro
//!     ↓
//! ┌─────────────┴─────────────┐
//! ↓                           ↓
//! Interpreter dispatch    JIT Cranelift IR
//! (lumen-rt/vm/mod.rs)   (lumen-codegen/jit.rs)
//! ```
//!
//! # Example
//!
//! ```rust,ignore
//! #[opcode(Add)]  // Maps to OpCode::Add
//! fn add(ctx: &mut OpContext, dest: Reg, lhs: Reg, rhs: Reg) -> Result<(), VmError> {
//!     // High-level semantics that work for both interpreter and JIT:
//!     let l = ctx.get_int(lhs)?;
//!     let r = ctx.get_int(rhs)?;
//!     ctx.set_int(dest, l.checked_add(r).ok_or(overflow_error("add"))?);
//!     Ok(())
//! }
//! ```
//!
//! This generates:
//! - Interpreter: Direct Rust code inserted into `match instr.op { OpCode::Add => { ... } }`
//! - JIT: Cranelift IR builder calls for add instruction

use lumen_core::lir::{Instruction, OpCode};
use lumen_core::values::Value;

/// Register identifier (0-255)
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct Reg(pub u8);

impl From<usize> for Reg {
    fn from(v: usize) -> Self {
        Reg(v as u8)
    }
}

impl From<u8> for Reg {
    fn from(v: u8) -> Self {
        Reg(v)
    }
}

/// Constant pool index
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ConstIdx(pub u16);

/// String table index
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct StrIdx(pub usize);

/// Opcode execution context - abstracts over interpreter and JIT
///
/// For the interpreter, this wraps VM registers and module data.
/// For JIT, this wraps Cranelift's FunctionBuilder and generates IR.
pub trait OpContext {
    /// Get value from register as Int
    fn get_int(&self, reg: Reg) -> Result<i64, String>;

    /// Get value from register as Float
    fn get_float(&self, reg: Reg) -> Result<f64, String>;

    /// Get value from register as Bool
    fn get_bool(&self, reg: Reg) -> Result<bool, String>;

    /// Get value from register (generic, returns Value enum)
    fn get_value(&self, reg: Reg) -> Result<Value, String>;

    /// Set register to Int
    fn set_int(&mut self, reg: Reg, val: i64);

    /// Set register to Float
    fn set_float(&mut self, reg: Reg, val: f64);

    /// Set register to Bool
    fn set_bool(&mut self, reg: Reg, val: bool);

    /// Set register to generic Value
    fn set_value(&mut self, reg: Reg, val: Value);

    /// Get constant from constant pool
    fn get_const(&self, idx: ConstIdx) -> Result<Value, String>;

    /// Get string from string table
    fn get_string(&self, idx: StrIdx) -> Result<String, String>;

    /// Signal jump to offset (signed)
    fn jump(&mut self, offset: i32);

    /// Signal conditional skip next instruction
    fn skip_next(&mut self, condition: bool);
}

/// Opcode definition metadata
///
/// Generated by #[opcode] macro, used to build dispatch tables and JIT functions.
#[derive(Debug, Clone)]
pub struct OpcodeDef {
    /// Name (e.g., "Add")
    pub name: &'static str,

    /// Corresponding OpCode enum variant
    pub opcode: OpCode,

    /// Encoding format (ABC, ABx, Ax, etc.)
    pub format: OpcodeFormat,

    /// Register operands with types
    pub operands: Vec<OperandSpec>,

    /// Human-readable description
    pub description: &'static str,

    /// Interpreter implementation (for direct code generation)
    pub interp_impl: InterpImpl,

    /// JIT implementation strategy
    pub jit_strategy: JitStrategy,
}

/// Instruction encoding format
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OpcodeFormat {
    /// Three 8-bit operands: op(8) a(8) b(8) c(8)
    ABC,
    /// One 8-bit + one 16-bit: op(8) a(8) Bx(16)
    ABx,
    /// One 24-bit operand: op(8) Ax(24)
    Ax,
    /// Signed 24-bit operand: op(8) sAx(24)
    SAx,
    /// Two operands, second is signed: op(8) a(8) sBx(16)
    ASBx,
}

/// Operand specification
#[derive(Debug, Clone)]
pub struct OperandSpec {
    pub name: &'static str,
    pub kind: OperandKind,
    pub ty: OperandType,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OperandKind {
    /// Register (source)
    Src,
    /// Register (destination)
    Dest,
    /// Constant pool index
    Const,
    /// String table index
    Str,
    /// Immediate value
    Imm,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OperandType {
    Int,
    Float,
    Bool,
    String,
    Value, // Generic runtime value
}

/// Interpreter implementation - generated code or closure
#[derive(Clone)]
pub struct InterpImpl {
    /// Direct code generation (preferred for performance)
    pub codegen: fn(&Instruction) -> String,

    /// Fallback: closure that executes the opcode
    /// (Used if codegen is too complex, or for testing)
    pub execute: Option<fn(&mut dyn OpContext, Instruction) -> Result<(), String>>,
}

impl std::fmt::Debug for InterpImpl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("InterpImpl")
            .field("has_codegen", &true)
            .field("has_execute", &self.execute.is_some())
            .finish()
    }
}

/// JIT compilation strategy
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum JitStrategy {
    /// Simple arithmetic/logic - direct IR instruction
    Direct,
    /// Requires type dispatch at runtime
    TypeDispatch,
    /// Calls a runtime helper function
    RuntimeCall,
    /// Complex control flow
    ControlFlow,
}

// ---------------------------------------------------------------------------
// Example opcode definitions
// ---------------------------------------------------------------------------

/// LoadK: Load constant from pool into register
///
/// Format: LoadK A Bx
/// Semantics: R[A] = K[Bx]
pub fn opcode_loadk() -> OpcodeDef {
    OpcodeDef {
        name: "LoadK",
        opcode: OpCode::LoadK,
        format: OpcodeFormat::ABx,
        operands: vec![
            OperandSpec {
                name: "dest",
                kind: OperandKind::Dest,
                ty: OperandType::Value,
            },
            OperandSpec {
                name: "const_idx",
                kind: OperandKind::Const,
                ty: OperandType::Value,
            },
        ],
        description: "Load constant from pool into register",
        interp_impl: InterpImpl {
            codegen: |_instr| {
                r#"
                let bx = instr.bx() as usize;
                let val = match &cell.constants[bx] {
                    Constant::Null => Value::Null,
                    Constant::Bool(v) => Value::Bool(*v),
                    Constant::Int(v) => Value::Int(*v),
                    Constant::BigInt(v) => Value::BigInt(v.clone()),
                    Constant::Float(v) => Value::Float(*v),
                    Constant::String(v) => Value::String(StringRef::Owned(v.clone())),
                };
                self.registers[base + a] = val;
                "#
                .to_string()
            },
            execute: None,
        },
        jit_strategy: JitStrategy::Direct,
    }
}

/// Add: Integer/Float addition with overflow checking
///
/// Format: Add A B C
/// Semantics: R[A] = R[B] + R[C]
pub fn opcode_add() -> OpcodeDef {
    OpcodeDef {
        name: "Add",
        opcode: OpCode::Add,
        format: OpcodeFormat::ABC,
        operands: vec![
            OperandSpec {
                name: "dest",
                kind: OperandKind::Dest,
                ty: OperandType::Value,
            },
            OperandSpec {
                name: "lhs",
                kind: OperandKind::Src,
                ty: OperandType::Value,
            },
            OperandSpec {
                name: "rhs",
                kind: OperandKind::Src,
                ty: OperandType::Value,
            },
        ],
        description: "Add two values (Int or Float) with overflow checking",
        interp_impl: InterpImpl {
            codegen: |_instr| {
                r#"
                let lhs = &self.registers[base + b];
                let rhs = &self.registers[base + c];
                let result = BinaryOp::Add.apply(lhs, rhs)?;
                self.registers[base + a] = result;
                "#
                .to_string()
            },
            execute: None,
        },
        jit_strategy: JitStrategy::TypeDispatch,
    }
}

/// Move: Copy register to register
///
/// Format: Move A B
/// Semantics: R[A] = R[B]
pub fn opcode_move() -> OpcodeDef {
    OpcodeDef {
        name: "Move",
        opcode: OpCode::Move,
        format: OpcodeFormat::ABC, // Uses only A and B
        operands: vec![
            OperandSpec {
                name: "dest",
                kind: OperandKind::Dest,
                ty: OperandType::Value,
            },
            OperandSpec {
                name: "src",
                kind: OperandKind::Src,
                ty: OperandType::Value,
            },
        ],
        description: "Copy value from one register to another (Rc bump for collections)",
        interp_impl: InterpImpl {
            codegen: |_instr| {
                r#"
                // Clone the source register. With Rc-wrapped collections this
                // is just a refcount increment (negligible cost). For scalars
                // (Int, Float, Bool) it is a tiny copy.
                self.registers[base + a] = self.registers[base + b].clone();
                "#
                .to_string()
            },
            execute: None,
        },
        jit_strategy: JitStrategy::Direct,
    }
}

/// LoadInt: Load small immediate integer
///
/// Format: LoadInt A sBx
/// Semantics: R[A] = sBx (sign-extended)
pub fn opcode_loadint() -> OpcodeDef {
    OpcodeDef {
        name: "LoadInt",
        opcode: OpCode::LoadInt,
        format: OpcodeFormat::ASBx,
        operands: vec![
            OperandSpec {
                name: "dest",
                kind: OperandKind::Dest,
                ty: OperandType::Int,
            },
            OperandSpec {
                name: "value",
                kind: OperandKind::Imm,
                ty: OperandType::Int,
            },
        ],
        description: "Load small signed integer immediate into register",
        interp_impl: InterpImpl {
            codegen: |_instr| {
                r#"
                let sb = instr.sbx();
                self.registers[base + a] = Value::Int(sb as i64);
                "#
                .to_string()
            },
            execute: None,
        },
        jit_strategy: JitStrategy::Direct,
    }
}

// ---------------------------------------------------------------------------
// Registry of all opcodes
// ---------------------------------------------------------------------------

/// Global opcode definition registry
///
/// Maps OpCode enum variants to their definitions.
/// Used by code generators to look up implementation details.
pub struct OpcodeRegistry {
    defs: Vec<OpcodeDef>,
}

impl OpcodeRegistry {
    /// Create a new registry with all standard opcodes
    pub fn new() -> Self {
        let defs = vec![
            opcode_loadk(),
            opcode_add(),
            opcode_move(),
            opcode_loadint(),
            // ... more opcodes would be registered here
        ];

        Self { defs }
    }

    /// Get definition for an opcode
    pub fn get(&self, opcode: OpCode) -> Option<&OpcodeDef> {
        self.defs.iter().find(|def| def.opcode == opcode)
    }

    /// Iterate over all opcode definitions
    pub fn iter(&self) -> impl Iterator<Item = &OpcodeDef> {
        self.defs.iter()
    }

    /// Generate interpreter dispatch code for all opcodes
    pub fn generate_interpreter_dispatch(&self) -> String {
        let mut code = String::from("match instr.op {\n");

        for def in &self.defs {
            code.push_str(&format!("    OpCode::{} => {{\n", def.name));
            code.push_str(&format!("        // {}\n", def.description));
            // Create a dummy instruction for codegen
            let dummy_instr = Instruction {
                op: def.opcode,
                pad: 0,
                a: 0,
                b: 0,
                c: 0,
            };
            code.push_str(&(def.interp_impl.codegen)(&dummy_instr));
            code.push_str("    }\n");
        }

        code.push_str("    _ => return Err(VmError::Runtime(\"unimplemented opcode\".into())),\n");
        code.push_str("}\n");
        code
    }

    /// Generate JIT compilation stub for an opcode
    pub fn generate_jit_stub(&self, opcode: OpCode) -> String {
        let def = match self.get(opcode) {
            Some(d) => d,
            None => return String::from("// Unknown opcode"),
        };

        format!(
            r#"
// JIT compilation for {}
// Strategy: {:?}
// {}
fn jit_{}(builder: &mut FunctionBuilder, instr: Instruction) -> Result<(), CodegenError> {{
    let a = instr.a;
    let b = instr.b;
    let c = instr.c;
    
    match def.jit_strategy {{
        JitStrategy::Direct => {{
            // TODO: Generate direct Cranelift IR
            unimplemented!("Direct IR generation for {}")
        }}
        JitStrategy::TypeDispatch => {{
            // TODO: Generate type-dispatched IR with runtime helpers
            unimplemented!("Type dispatch for {}")
        }}
        JitStrategy::RuntimeCall => {{
            // TODO: Call runtime helper function
            unimplemented!("Runtime call for {}")
        }}
        JitStrategy::ControlFlow => {{
            // TODO: Generate control flow blocks
            unimplemented!("Control flow for {}")
        }}
    }}
}}
"#,
            def.name,
            def.jit_strategy,
            def.description,
            def.name.to_lowercase(),
            def.name,
            def.name,
            def.name,
            def.name,
        )
    }
}

impl Default for OpcodeRegistry {
    fn default() -> Self {
        Self::new()
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_registry_creation() {
        let registry = OpcodeRegistry::new();

        // Check that we can look up opcodes
        assert!(registry.get(OpCode::LoadK).is_some());
        assert!(registry.get(OpCode::Add).is_some());
        assert!(registry.get(OpCode::Move).is_some());

        // Check metadata
        let add_def = registry.get(OpCode::Add).unwrap();
        assert_eq!(add_def.name, "Add");
        assert_eq!(add_def.format, OpcodeFormat::ABC);
        assert_eq!(add_def.operands.len(), 3);
    }

    #[test]
    fn test_generate_dispatch_code() {
        let registry = OpcodeRegistry::new();
        let code = registry.generate_interpreter_dispatch();

        // Should contain match statement and opcode cases
        assert!(code.contains("match instr.op"));
        assert!(code.contains("OpCode::LoadK"));
        assert!(code.contains("OpCode::Add"));
        assert!(code.contains("OpCode::Move"));
    }

    #[test]
    fn test_generate_jit_stub() {
        let registry = OpcodeRegistry::new();
        let stub = registry.generate_jit_stub(OpCode::Add);

        // Should contain function signature and strategy
        assert!(stub.contains("fn jit_add"));
        assert!(stub.contains("TypeDispatch"));
    }

    #[test]
    fn test_opcode_formats() {
        let loadk = opcode_loadk();
        assert_eq!(loadk.format, OpcodeFormat::ABx);

        let add = opcode_add();
        assert_eq!(add.format, OpcodeFormat::ABC);

        let loadint = opcode_loadint();
        assert_eq!(loadint.format, OpcodeFormat::ASBx);
    }
}
