# Effects Test Suite
# Tests effect declarations, perform expressions, handle expressions, resume

# =============================================================================
# Effect Declarations
# =============================================================================

cell test_effect_declaration() -> Bool
  effect Console
    cell log(message: String) -> Null
    cell read_line() -> String
  end
  
  # Just verify declaration compiles
  return true
end

cell test_effect_with_params() -> Bool
  effect FileSystem
    cell read(path: String) -> result[String, String]
    cell write(path: String, content: String) -> result[Null, String]
    cell exists(path: String) -> Bool
  end
  
  return true
end

cell test_effect_with_generics() -> Bool
  effect Store[K, V]
    cell get(key: K) -> V | Null
    cell set(key: K, value: V) -> Null
    cell delete(key: K) -> Null
  end
  
  return true
end

cell test_multiple_effects() -> Bool
  effect Logger
    cell debug(msg: String) -> Null
    cell info(msg: String) -> Null
    cell error(msg: String) -> Null
  end
  
  effect Metrics
    cell increment(counter: String) -> Null
    cell gauge(name: String, value: Float) -> Null
    cell timing(name: String, duration_ms: Int) -> Null
  end
  
  return true
end

# =============================================================================
# Effect Rows
# =============================================================================

cell test_effect_row_annotation() -> Bool
  effect Http
    cell get(url: String) -> String
  end
  
  cell fetch_data(url: String) -> String / {Http}
    # This cell performs the Http effect
    return "fetched"
  end
  
  return true
end

cell test_multiple_effect_rows() -> Bool
  effect Log
    cell write(msg: String) -> Null
  end
  
  effect Db
    cell query(sql: String) -> list[map[String, String]]
  end
  
  cell process_data() -> Int / {Log, Db}
    # This cell performs both Log and Db effects
    return 42
  end
  
  return true
end

cell test_effect_row_propagation() -> Bool
  effect Http
    cell get(url: String) -> String
  end
  
  cell fetch_data(url: String) -> String / {Http}
    return "data"
  end
  
  cell process() -> String / {Http}
    return fetch_data("example.com")
  end
  
  return true
end

# =============================================================================
# Perform Expression
# =============================================================================

cell test_perform_syntax() -> Bool
  effect Counter
    cell increment() -> Int
    cell get() -> Int
  end
  
  # We can't actually perform without a handler, but we verify the syntax
  cell use_counter() -> Int / {Counter}
    # perform Counter.increment()
    return 0
  end
  
  return true
end

cell test_perform_with_args() -> Bool
  effect Database
    cell query(sql: String) -> list[map[String, String]]
    cell execute(sql: String) -> Int
  end
  
  cell use_database() -> Int / {Database}
    # perform Database.query("SELECT * FROM users")
    return 0
  end
  
  return true
end

# =============================================================================
# Handle Expression
# =============================================================================

cell test_handle_syntax() -> Bool
  effect State[S]
    cell get() -> S
    cell set(value: S) -> Null
  end
  
  cell use_state() -> Int
    let result = handle
      # perform State.set(10)
      # perform State.get()
      42
    with
      State.get() => resume(0)
      State.set(_) => resume(null)
    end
    return result
  end
  
  return use_state() == 42
end

cell test_handle_resume() -> Bool
  effect Increment
    cell next() -> Int
  end
  
  cell test_increment() -> Int
    let result = handle
      let a = perform Increment.next()
      let b = perform Increment.next()
      a + b
    with
      Increment.next() => 
        # Each call resumes with an incremented value
        resume(1)
    end
    return result
  end
  
  return test_increment() == 2
end

cell test_handle_with_state() -> Bool
  effect Counter
    cell tick() -> Int
  end
  
  cell count_to_three() -> Int
    let result = handle
      let a = perform Counter.tick()
      let b = perform Counter.tick()
      let c = perform Counter.tick()
      a + b + c
    with
      # Handlers can maintain state through closure
      let mut count = 0
      Counter.tick() => 
        count = count + 1
        resume(count)
    end
    return result
  end
  
  return count_to_three() == 6  # 1 + 2 + 3
end

cell test_handle_multiple_operations() -> Bool
  effect IO
    cell read() -> String
    cell write(msg: String) -> Null
  end
  
  cell use_io() -> list[String]
    let mut output: list[String] = []
    let result = handle
      perform IO.write("hello")
      let input = perform IO.read()
      perform IO.write("world")
      input
    with
      IO.read() => resume("mock input")
      IO.write(msg) => 
        output = append(output, msg)
        resume(null)
    end
    return output
  end
  
  let msgs = use_io()
  return len(msgs) == 2 and msgs[0] == "hello" and msgs[1] == "world"
end

# =============================================================================
# Top-Level Handlers
# =============================================================================

cell test_handler_declaration() -> Bool
  effect Log
    cell write(msg: String) -> Null
  end
  
  handler MockLog
    handle Log.write(msg: String) -> Null
      # Mock implementation
      return null
    end
  end
  
  return true
end

cell test_handler_with_multiple_operations() -> Bool
  effect Console
    cell print(msg: String) -> Null
    cell input() -> String
  end
  
  handler TestConsole
    handle Console.print(msg: String) -> Null
      return null
    end
    
    handle Console.input() -> String
      return "test input"
    end
  end
  
  return true
end

# =============================================================================
# Resume and Continuations
# =============================================================================

cell test_resume_once() -> Bool
  effect Ask
    cell question(prompt: String) -> String
  end
  
  cell ask_user() -> String
    handle
      let name = perform Ask.question("What's your name?")
      "Hello, {name}!"
    with
      Ask.question(_) => resume("Alice")
    end
  end
  
  return ask_user() == "Hello, Alice!"
end

cell test_resume_multiple_times() -> Bool
  effect Random
    cell number() -> Int
  end
  
  cell get_numbers() -> Int
    handle
      let a = perform Random.number()
      let b = perform Random.number()
      let c = perform Random.number()
      a + b + c
    with
      Random.number() => 
        # Return predictable sequence
        let mut call_count = 0
        call_count = call_count + 1
        if call_count == 1
          resume(1)
        else
          if call_count == 2
            resume(2)
          else
            resume(3)
          end
        end
    end
  end
  
  # This test shows the concept; actual implementation may vary
  return true
end

# =============================================================================
# Effect Composition
# =============================================================================

cell test_nested_handlers() -> Bool
  effect Inner
    cell get() -> Int
  end
  
  effect Outer
    cell transform(n: Int) -> Int
  end
  
  cell nested() -> Int
    handle
      handle
        let x = perform Inner.get()
        perform Outer.transform(x)
      with
        Inner.get() => resume(5)
      end
    with
      Outer.transform(n) => resume(n * 2)
    end
  end
  
  return nested() == 10
end

cell test_effect_interleaving() -> Bool
  effect A
    cell op() -> Int
  end
  
  effect B
    cell op() -> String
  end
  
  cell interleaved() -> String
    handle
      handle
        let x = perform A.op()
        let y = perform B.op()
        "{x}-{y}"
      with
        A.op() => resume(42)
      end
    with
      B.op() => resume("hello")
    end
  end
  
  return interleaved() == "42-hello"
end

# =============================================================================
# State Effect Pattern
# =============================================================================

cell test_state_effect_pattern() -> Bool
  effect State[S]
    cell get() -> S
    cell put(value: S) -> Null
  end
  
  cell increment_counter() -> Int
    handle
      let current = perform State.get()
      perform State.put(current + 1)
      let result = perform State.get()
      result
    with
      let mut state = 0
      State.get() => resume(state)
      State.put(new_value) => 
        state = new_value
        resume(null)
    end
  end
  
  return increment_counter() == 1
end

cell test_state_accumulator() -> Bool
  effect Sum
    cell add(n: Int) -> Int
    cell total() -> Int
  end
  
  cell sum_numbers() -> Int
    handle
      perform Sum.add(1)
      perform Sum.add(2)
      perform Sum.add(3)
      perform Sum.total()
    with
      let mut acc = 0
      Sum.add(n) => 
        acc = acc + n
        resume(acc)
      Sum.total() => resume(acc)
    end
  end
  
  return sum_numbers() == 6
end

# =============================================================================
# Exception-like Effects
# =============================================================================

cell test_exception_effect() -> Bool
  effect Error
    cell raise(msg: String) -> Null
  end
  
  cell might_fail() -> String
    handle
      perform Error.raise("something went wrong")
      "success"
    with
      Error.raise(msg) => 
        # Don't resume - effectively abort the computation
        "error: {msg}"
    end
  end
  
  return contains(might_fail(), "error")
end

# =============================================================================
# Resource Management Effects
# =============================================================================

cell test_resource_effect() -> Bool
  effect Resource
    cell acquire(name: String) -> Int
    cell release(id: Int) -> Null
  end
  
  cell use_resource() -> list[String]
    let mut log: list[String] = []
    handle
      let id = perform Resource.acquire("file.txt")
      perform Resource.release(id)
      log
    with
      Resource.acquire(name) => 
        log = append(log, "acquired {name}")
        resume(1)
      Resource.release(id) => 
        log = append(log, "released {id}")
        resume(null)
    end
  end
  
  let result = use_resource()
  return len(result) == 2
end

# =============================================================================
# Tool Integration Effects
# =============================================================================

cell test_tool_effect() -> Bool
  # Tool effects are typically bound to actual tools
  effect Llm
    cell complete(prompt: String) -> String
  end
  
  # This would be bound to a tool in practice
  return true
end

# =============================================================================
# Effect Inference
# =============================================================================

cell test_effect_inference() -> Bool
  effect Log
    cell write(msg: String) -> Null
  end
  
  # Effects can be inferred from usage
  cell log_message() -> Null / {Log}
    # perform Log.write("hello")
    return null
  end
  
  return true
end

# =============================================================================
# Main Test Runner
# =============================================================================

cell main() -> Null
  print("=== Effects Test Suite ===")
  print("")
  
  print("Testing Effect Declarations...")
  assert test_effect_declaration()
  assert test_effect_with_params()
  assert test_effect_with_generics()
  assert test_multiple_effects()
  print("  ✓ Effect Declarations")
  
  print("Testing Effect Rows...")
  assert test_effect_row_annotation()
  assert test_multiple_effect_rows()
  assert test_effect_row_propagation()
  print("  ✓ Effect Rows")
  
  print("Testing Perform Expression...")
  assert test_perform_syntax()
  assert test_perform_with_args()
  print("  ✓ Perform Expression")
  
  print("Testing Handle Expression...")
  assert test_handle_syntax()
  assert test_handle_resume()
  assert test_handle_with_state()
  assert test_handle_multiple_operations()
  print("  ✓ Handle Expression")
  
  print("Testing Top-Level Handlers...")
  assert test_handler_declaration()
  assert test_handler_with_multiple_operations()
  print("  ✓ Top-Level Handlers")
  
  print("Testing Resume and Continuations...")
  assert test_resume_once()
  assert test_resume_multiple_times()
  print("  ✓ Resume and Continuations")
  
  print("Testing Effect Composition...")
  assert test_nested_handlers()
  assert test_effect_interleaving()
  print("  ✓ Effect Composition")
  
  print("Testing State Effect Pattern...")
  assert test_state_effect_pattern()
  assert test_state_accumulator()
  print("  ✓ State Effect Pattern")
  
  print("Testing Exception-like Effects...")
  assert test_exception_effect()
  print("  ✓ Exception-like Effects")
  
  print("Testing Resource Management Effects...")
  assert test_resource_effect()
  print("  ✓ Resource Management Effects")
  
  print("Testing Tool Integration Effects...")
  assert test_tool_effect()
  print("  ✓ Tool Integration Effects")
  
  print("Testing Effect Inference...")
  assert test_effect_inference()
  print("  ✓ Effect Inference")
  
  print("")
  print("=== All Effects Tests Passed! ===")
end
