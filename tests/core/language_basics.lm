# Language Basics Test Suite
# Tests fundamental language features: variables, types, operators

# =============================================================================
# Variables and Assignments
# =============================================================================

cell test_variable_declaration() -> Bool
  let x = 42
  let y: Int = 100
  let name = "Lumen"
  let pi = 3.14
  let active = true
  return x == 42 and y == 100 and name == "Lumen" and pi == 3.14 and active == true
end

cell test_mutable_variables() -> Bool
  let mut counter = 0
  counter = 1
  counter = 2
  return counter == 2
end

cell test_multiple_declarations() -> Bool
  let a = 1
  let b = 2
  let c = 3
  return a + b + c == 6
end

# =============================================================================
# Basic Types
# =============================================================================

cell test_int_type_of() -> Bool
  let zero = 0
  let positive = 42
  let negative = -17
  let large = 1000000000
  return type_of(zero) == "Int" and type_of(positive) == "Int" and type_of(negative) == "Int"
end

# TODO: use 1.5e10 when scientific notation is supported (T191 / ROADMAP)
cell test_float_type_of() -> Bool
  let pi = 3.14159
  let negative = -0.5
  let whole = 10.0
  let scientific = 15000000000.0
  return type_of(pi) == "Float" and type_of(negative) == "Float"
end

cell test_string_type_of() -> Bool
  let empty = ""
  let hello = "hello"
  let multiline = "line1\nline2"
  return type_of(empty) == "String" and type_of(hello) == "String" and len(hello) == 5
end

cell test_bool_type_of() -> Bool
  let t = true
  let f = false
  return type_of(t) == "Bool" and type_of(f) == "Bool" and t != f
end

cell test_null_type_of() -> Bool
  let n = null
  return type_of(n) == "Null" and n == null
end

# =============================================================================
# Arithmetic Operations
# =============================================================================

# TODO(T193): Many consecutive assert <literal op literal> triggers VM/compiler register reuse (null in binop). Use one combined check per cell until fixed.
cell test_basic_arithmetic() -> Bool
  let ok = (1 + 1 == 2) and (10 + 20 == 30) and ((-5) + 5 == 0)
    and (10 - 3 == 7) and (5 - 10 == -5) and (0 - 0 == 0)
    and (3 * 4 == 12) and ((-2) * 3 == -6) and (0 * 100 == 0)
    and (10 / 2 == 5) and (7 / 2 == 3) and ((-9) / 3 == -3)
    and (10 % 3 == 1) and (15 % 5 == 0) and (7 % 4 == 3)
    and (2 ** 3 == 8) and (3 ** 2 == 9) and (10 ** 0 == 1)
  assert ok
  return true
end

cell test_float_arithmetic() -> Bool
  let ok = (3.0 + 2.0 == 5.0) and (5.5 - 2.5 == 3.0) and (2.5 * 4.0 == 10.0) and (7.5 / 2.5 == 3.0)
  assert ok
  return true
end

cell test_mixed_arithmetic() -> Bool
  # Int and Float operations result in Float
  let result = 5 + 3.0
  return type_of(result) == "Float" and result == 8.0
end

cell test_compound_assignment() -> Bool
  let mut x = 10
  x += 5
  x -= 3
  x *= 2
  x /= 4
  x %= 4
  let ok = x == 2
  assert ok
  return true
end

cell test_operator_precedence() -> Bool
  let ok = (2 + 3 * 4 == 14) and ((2 + 3) * 4 == 20) and (10 - 4 / 2 == 8) and (2 ** 3 + 1 == 9) and (2 * 3 + 4 * 5 == 26)
  assert ok
  return true
end

# =============================================================================
# Comparison Operators
# =============================================================================

cell test_comparison_operators() -> Bool
  let ok = (5 == 5) and ("hello" == "hello") and (true == true)
    and (5 != 3) and ("a" != "b") and (true != false)
    and (3 < 5) and ((-1) < 0) and (10 > 5) and (0 > (-10))
    and (5 <= 5) and (3 <= 5) and (5 >= 5) and (10 >= 5)
  assert ok
  return true
end

cell test_string_comparison() -> Bool
  let ok = ("a" < "b") and ("apple" < "banana") and ("hello" == "hello") and ("Hello" != "hello")
  assert ok
  return true
end

# =============================================================================
# Logical Operators
# =============================================================================

cell test_logical_and() -> Bool
  let ok = (true and true) and (not (true and false)) and (not (false and true)) and (not (false and false))
  assert ok
  return true
end

cell test_logical_or() -> Bool
  let ok = (true or true) and (true or false) and (false or true) and (not (false or false))
  assert ok
  return true
end

cell test_logical_not() -> Bool
  let ok = (not false) and (not (not true)) and (not (5 == 3))
  assert ok
  return true
end

# TODO: re-add side-effect check when language supports inline block with semicolons
# (e.g. { side_effect = 1; true }) or equivalent; see T192 / language drift
cell test_logical_short_circuit() -> Bool
  let result1 = false and true
  let result2 = true or false
  let ok = (not result1) and result2
  assert ok
  return true
end

cell test_combined_logical() -> Bool
  let ok = ((true and true) or false) and (not (false and (true or false))) and ((5 > 3) and (10 < 20)) and ((5 == 5) or (3 == 4))
  assert ok
  return true
end

# =============================================================================
# Bitwise Operators
# =============================================================================

cell test_bitwise_and() -> Bool
  let ok = ((5 & 3) == 1) and ((7 & 7) == 7) and ((0 & 255) == 0)
  assert ok
  return true
end

cell test_bitwise_or() -> Bool
  let ok = ((5 | 3) == 7) and ((1 | 2) == 3) and ((0 | 255) == 255)
  assert ok
  return true
end

cell test_bitwise_xor() -> Bool
  let ok = ((5 ^ 3) == 6) and ((7 ^ 7) == 0)
  assert ok
  return true
end

cell test_bitwise_shifts() -> Bool
  let ok = ((1 << 3) == 8) and ((8 >> 2) == 2) and ((255 >> 4) == 15)
  assert ok
  return true
end

cell test_bitwise_not() -> Bool
  let result = ~0
  return result != 0  # bitwise NOT should flip bits
end

# =============================================================================
# String Operations
# =============================================================================

cell test_string_concatenation() -> Bool
  let ok = ("hello" + " " + "world" == "hello world") and ("" + "test" == "test") and ("a" + "b" + "c" == "abc")
  assert ok
  return true
end

cell test_string_interpolation() -> Bool
  let name = "World"
  let count = 42
  let result = "Hello, {name}! Count: {count}"
  let ok = contains(result, "Hello") and contains(result, "World") and contains(result, "42")
  assert ok
  return true
end

cell test_string_length() -> Bool
  let ok = (len("") == 0) and (len("a") == 1) and (len("hello") == 5) and (len("hello world") == 11)
  assert ok
  return true
end

# =============================================================================
# Type Checking
# =============================================================================

cell test_type_of() -> Bool
  let ok = (type_of(42) == "Int") and (type_of(3.14) == "Float") and (type_of("hello") == "String") and (type_of(true) == "Bool") and (type_of(null) == "Null") and (type_of([1, 2, 3]) == "list[Int]")
  assert ok
  return true
end

# TODO(T196): Language uses to_int/to_float (not parse_int/parse_float) for string->number conversion.
cell test_type_conversion() -> Bool
  let ok = (to_string(42) == "42") and (to_string(3.14) == "3.14") and (to_string(true) == "true") and (to_int("42") == 42) and (to_int("-17") == -17) and (to_float("3.14") == 3.14)
  assert ok
  return true
end

# =============================================================================
# Edge Cases
# =============================================================================

# TODO(T197): Literal -9223372036854775808 (i64::MIN) triggers "cannot negate" (overflow); test min_int with smaller literal.
cell test_integer_edge_cases() -> Bool
  let max_int = 9223372036854775807
  let ok = max_int > 0 and (-1 < 0)
  assert ok
  return true
end

cell test_division_edge_cases() -> Bool
  let a = 10
  let b = 1
  let ok = a / b == 10
  assert ok
  return true
end

cell test_empty_collections() -> Bool
  let empty_list: list[Int] = []
  let empty_map: map[String, Int] = {}
  let empty_set: set[Int] = {}
  let ok = (len(empty_list) == 0) and (len(empty_map) == 0) and (len(empty_set) == 0)
  assert ok
  return true
end

# =============================================================================
# Main Test Runner
# =============================================================================

# TODO(T193): Single assert for all results to avoid VM register reuse after consecutive assert calls.
cell main() -> Null
  print("=== Language Basics Test Suite ===")
  print("")
  
  print("Testing Variables and Assignments...")
  let v = test_variable_declaration() and test_mutable_variables() and test_multiple_declarations()
  assert v
  print("  ✓ Variables and Assignments")
  
  print("Testing Basic Types...")
  let t = test_int_type_of() and test_float_type_of() and test_string_type_of() and test_bool_type_of() and test_null_type_of()
  assert t
  print("  ✓ Basic Types")
  
  print("Testing Arithmetic Operations...")
  let a = test_basic_arithmetic() and test_float_arithmetic() and test_mixed_arithmetic() and test_compound_assignment() and test_operator_precedence()
  assert a
  print("  ✓ Arithmetic Operations")
  
  print("Testing Comparison Operators...")
  let c = test_comparison_operators() and test_string_comparison()
  assert c
  print("  ✓ Comparison Operators")
  
  print("Testing Logical Operators...")
  let l = test_logical_and() and test_logical_or() and test_logical_not() and test_logical_short_circuit() and test_combined_logical()
  assert l
  print("  ✓ Logical Operators")
  
  print("Testing Bitwise Operators...")
  let b = test_bitwise_and() and test_bitwise_or() and test_bitwise_xor() and test_bitwise_shifts() and test_bitwise_not()
  assert b
  print("  ✓ Bitwise Operators")
  
  print("Testing String Operations...")
  let s = test_string_concatenation() and test_string_interpolation() and test_string_length()
  assert s
  print("  ✓ String Operations")
  
  print("Testing Type Checking...")
  let y = test_type_of() and test_type_conversion()
  assert y
  print("  ✓ Type Checking")
  
  print("Testing Edge Cases...")
  let e = test_integer_edge_cases() and test_division_edge_cases() and test_empty_collections()
  assert e
  print("  ✓ Edge Cases")
  
  print("")
  print("=== All Language Basics Tests Passed! ===")
end
