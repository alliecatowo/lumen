# Types Test Suite
# Tests records, enums, generics, unions, type aliases, optional types

# =============================================================================
# Records
# =============================================================================

cell test_basic_record() -> Bool
  record Point
    x: Int
    y: Int
  end
  
  let p = Point(x: 3, y: 4)
  return p.x == 3 and p.y == 4
end

cell test_record_field_access() -> Bool
  record Person
    name: String
    age: Int
  end
  
  let person = Person(name: "Alice", age: 30)
  return person.name == "Alice" and person.age == 30
end

cell test_record_equality() -> Bool
  record Coord
    x: Int
    y: Int
  end
  
  let c1 = Coord(x: 1, y: 2)
  let c2 = Coord(x: 1, y: 2)
  let c3 = Coord(x: 2, y: 1)
  
  return c1.x == c2.x and c1.y == c2.y and c1.x != c3.x
end

cell test_record_with_defaults() -> Bool
  record Config
    host: String = "localhost"
    port: Int = 8080
    debug: Bool = false
  end
  
  let cfg1 = Config()  # all defaults
  let cfg2 = Config(port: 3000)  # override one
  
  return cfg1.host == "localhost" and cfg1.port == 8080 and cfg2.port == 3000
end

cell test_record_with_constraints() -> Bool
  record PositiveNumber
    value: Int where value > 0
  end
  
  let n = PositiveNumber(value: 42)
  return n.value == 42
end

cell test_record_update() -> Bool
  record Rectangle
    width: Int
    height: Int
  end
  
  let r1 = Rectangle(width: 10, height: 20)
  let r2 = Rectangle(width: 15, height: r1.height)
  
  return r1.width == 10 and r2.width == 15 and r2.height == 20
end

cell test_nested_records() -> Bool
  record Address
    street: String
    city: String
  end
  
  record Contact
    name: String
    address: Address
  end
  
  let addr = Address(street: "123 Main St", city: "NYC")
  let contact = Contact(name: "Bob", address: addr)
  
  return contact.address.city == "NYC"
end

cell test_record_methods() -> Bool
  record Vector2D
    x: Float
    y: Float
  
    cell magnitude(self: Vector2D) -> Float
      return sqrt(self.x * self.x + self.y * self.y)
    end
    
    cell add(self: Vector2D, other: Vector2D) -> Vector2D
      return Vector2D(x: self.x + other.x, y: self.y + other.y)
    end
  end
  
  let v1 = Vector2D(x: 3.0, y: 4.0)
  let v2 = Vector2D(x: 1.0, y: 2.0)
  let v3 = v1.add(v2)
  
  return v1.magnitude() == 5.0 and v3.x == 4.0 and v3.y == 6.0
end

# =============================================================================
# Generic Records
# =============================================================================

cell test_generic_record() -> Bool
  record Box[T]
    value: T
  end
  
  let int_box = Box[Int](value: 42)
  let str_box = Box[String](value: "hello")
  
  return int_box.value == 42 and str_box.value == "hello"
end

cell test_generic_pair() -> Bool
  record Pair[A, B]
    first: A
    second: B
  end
  
  let p1 = Pair[Int, String](first: 1, second: "one")
  let p2 = Pair[Bool, Float](first: true, second: 3.14)
  
  return p1.first == 1 and p2.second == 3.14
end

cell test_generic_stack() -> Bool
  record Stack[T]
    items: list[T]
  
    cell push(self: Stack[T], item: T) -> Stack[T]
      return Stack(items: append(self.items, item))
    end
    
    cell pop(self: Stack[T]) -> tuple[T | Null, Stack[T]]
      let len_items = len(self.items)
      if len_items == 0
        return (null, self)
      end
      let top = self.items[len_items - 1]
      let rest = slice(self.items, 0, len_items - 1)
      return (top, Stack(items: rest))
    end
    
    cell is_empty(self: Stack[T]) -> Bool
      return len(self.items) == 0
    end
  end
  
  let s1 = Stack[Int](items: [])
  let s2 = s1.push(1).push(2).push(3)
  let (top, s3) = s2.pop()
  
  return top == 3 and not s3.is_empty()
end

# =============================================================================
# Enums
# =============================================================================

cell test_basic_enum() -> Bool
  enum Color
    Red
    Green
    Blue
  end
  
  let c = Color.Green
  return c == Color.Green
end

cell test_enum_with_payload() -> Bool
  enum Shape
    Circle(radius: Float)
    Rectangle(width: Float, height: Float)
    Point
  end
  
  let s1 = Shape.Circle(radius: 5.0)
  let s2 = Shape.Rectangle(width: 10.0, height: 20.0)
  let s3 = Shape.Point
  
  return true  # Just verify they compile and construct
end

cell test_enum_match() -> Bool
  enum Result
    Success(value: Int)
    Failure(error: String)
  end
  
  cell process(r: Result) -> String
    match r
      Result.Success(v) -> return "success:{v}"
      Result.Failure(e) -> return "error:{e}"
    end
  end
  
  let r1 = Result.Success(value: 42)
  let r2 = Result.Failure(error: "not found")
  
  return process(r1) == "success:42" and contains(process(r2), "error")
end

cell test_enum_generic() -> Bool
  enum Option[T]
    Some(T)
    None
  end
  
  let o1 = Option[Int].Some(42)
  let o2 = Option[String].None
  
  match o1
    Option.Some(v) -> return v == 42
    Option.None -> return false
  end
end

cell test_enum_recursive() -> Bool
  enum Tree[T]
    Leaf
    Node(value: T, left: Tree[T], right: Tree[T])
  end
  
  let tree = Tree[Int].Node(
    value: 1,
    left: Tree[Int].Node(value: 2, left: Tree[Int].Leaf, right: Tree[Int].Leaf),
    right: Tree[Int].Leaf
  )
  
  return true  # Verify construction works
end

cell test_enum_methods() -> Bool
  enum Status
    Pending
    Completed(result: String)
    Failed(error: String)
    
    cell is_done(self: Status) -> Bool
      match self
        Status.Pending -> return false
        Status.Completed(_) -> return true
        Status.Failed(_) -> return true
      end
    end
    
    cell get_result(self: Status) -> String | Null
      match self
        Status.Completed(r) -> return r
        _ -> return null
      end
    end
  end
  
  let s1 = Status.Pending
  let s2 = Status.Completed(result: "done")
  
  return not s1.is_done() and s2.is_done() and s2.get_result() == "done"
end

# =============================================================================
# Union Types
# =============================================================================

cell test_union_type() -> Bool
  let x: Int | String = 42
  let y: Int | String = "hello"
  
  return true  # Verify type annotations work
end

cell test_union_type_check() -> Bool
  let value: Int | String | Bool = 42
  
  if value is Int
    return true
  end
  if value is String
    return false
  end
  return false
end

cell test_union_with_null() -> Bool
  let x: Int | Null = 42
  let y: Int | Null = null
  
  return x != null and y == null
end

cell test_union_narrowing() -> Bool
  cell process(v: Int | String) -> String
    if v is Int
      return "int:{v}"
    else
      return "string:{v}"
    end
  end
  
  return process(42) == "int:42" and process("hi") == "string:hi"
end

# =============================================================================
# Optional Types
# =============================================================================

cell test_optional_type() -> Bool
  let x: Int? = 42
  let y: Int? = null
  
  return x != null and y == null
end

cell test_optional_sugar() -> Bool
  # Int? is sugar for Int | Null
  let a: Int? = 5
  let b: Int? = null
  
  return true  # Verify syntax compiles
end

cell test_null_safe_access() -> Bool
  record User
    name: String
    email: String | Null
  end
  
  let u1 = User(name: "Alice", email: "alice@example.com")
  let u2 = User(name: "Bob", email: null)
  
  let e1 = u1.email ?? "no email"
  let e2 = u2.email ?? "no email"
  
  return e1 == "alice@example.com" and e2 == "no email"
end

cell test_optional_unwrap() -> Bool
  let x: Int? = 42
  
  if x != null
    let unwrapped: Int = x
    return unwrapped == 42
  end
  return false
end

# =============================================================================
# Type Aliases
# =============================================================================

cell test_type_alias() -> Bool
  type UserId = Int
  type Username = String
  
  let id: UserId = 12345
  let name: Username = "alice"
  
  return id == 12345 and name == "alice"
end

cell test_type_alias_complex() -> Bool
  type Point2D = tuple[Int, Int]
  type StringList = list[String]
  type IntMap = map[String, Int]
  
  let p: Point2D = (3, 4)
  let lst: StringList = ["a", "b"]
  let m: IntMap = {"x": 1, "y": 2}
  
  return p[0] == 3 and len(lst) == 2 and m["x"] == 1
end

cell test_type_alias_function() -> Bool
  type BinaryOp = fn(Int, Int) -> Int
  type Predicate = fn(Int) -> Bool
  
  let add: BinaryOp = fn(a, b) => a + b
  let is_even: Predicate = fn(x) => x % 2 == 0
  
  return add(2, 3) == 5 and is_even(4)
end

# =============================================================================
# Result Type
# =============================================================================

cell test_result_type() -> Bool
  cell safe_divide(a: Int, b: Int) -> result[Int, String]
    if b == 0
      return err("division by zero")
    end
    return ok(a / b)
  end
  
  let r1 = safe_divide(10, 2)
  let r2 = safe_divide(10, 0)
  
  return is_ok(r1) and is_err(r2)
end

cell test_result_unwrap() -> Bool
  let r1 = ok(42)
  let r2 = err("error")
  
  return unwrap(r1) == 42 and unwrap_or(r2, 0) == 0
end

cell test_result_match() -> Bool
  cell handle_result(r: result[Int, String]) -> String
    match r
      ok(v) -> return "success:{v}"
      err(e) -> return "error:{e}"
    end
  end
  
  return handle_result(ok(5)) == "success:5" and handle_result(err("x")) == "error:x"
end

cell test_result_try() -> Bool
  cell divide_chain(a: Int, b: Int, c: Int) -> result[Int, String]
    let x = try safe_divide(a, b)?
    let y = try safe_divide(x, c)?
    return ok(y)
  end
  
  # Just verify compilation
  return true
end

# =============================================================================
# Generic Type Constraints
# =============================================================================

cell test_generic_function() -> Bool
  cell identity[T](x: T) -> T
    return x
  end
  
  cell swap[A, B](a: A, b: B) -> tuple[B, A]
    return (b, a)
  end
  
  let i = identity(42)
  let s = swap(1, "one")
  
  return i == 42 and s[0] == "one" and s[1] == 1
end

cell test_generic_collection() -> Bool
  cell first[T](items: list[T]) -> T | Null
    if len(items) > 0
      return items[0]
    end
    return null
  end
  
  return first([1, 2, 3]) == 1 and first([]) == null
end

# =============================================================================
# Main Test Runner
# =============================================================================

cell main() -> Null
  print("=== Types Test Suite ===")
  print("")
  
  print("Testing Records...")
  assert test_basic_record()
  assert test_record_field_access()
  assert test_record_equality()
  assert test_record_with_defaults()
  assert test_record_with_constraints()
  assert test_record_update()
  assert test_nested_records()
  assert test_record_methods()
  print("  ✓ Records")
  
  print("Testing Generic Records...")
  assert test_generic_record()
  assert test_generic_pair()
  assert test_generic_stack()
  print("  ✓ Generic Records")
  
  print("Testing Enums...")
  assert test_basic_enum()
  assert test_enum_with_payload()
  assert test_enum_match()
  assert test_enum_generic()
  assert test_enum_recursive()
  assert test_enum_methods()
  print("  ✓ Enums")
  
  print("Testing Union Types...")
  assert test_union_type()
  assert test_union_type_check()
  assert test_union_with_null()
  assert test_union_narrowing()
  print("  ✓ Union Types")
  
  print("Testing Optional Types...")
  assert test_optional_type()
  assert test_optional_sugar()
  assert test_null_safe_access()
  assert test_optional_unwrap()
  print("  ✓ Optional Types")
  
  print("Testing Type Aliases...")
  assert test_type_alias()
  assert test_type_alias_complex()
  assert test_type_alias_function()
  print("  ✓ Type Aliases")
  
  print("Testing Result Type...")
  assert test_result_type()
  assert test_result_unwrap()
  assert test_result_match()
  assert test_result_try()
  print("  ✓ Result Type")
  
  print("Testing Generic Functions...")
  assert test_generic_function()
  assert test_generic_collection()
  print("  ✓ Generic Functions")
  
  print("")
  print("=== All Types Tests Passed! ===")
end
